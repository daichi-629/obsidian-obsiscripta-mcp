/**
 * Admin API routes for managing plugin tokens.
 * Protected by admin secret (Bearer token).
 *
 * Plugin tokens are used for MCP server â†’ Obsidian plugin communication.
 * The Obsidian plugin generates a token, which is then registered here
 * via the admin API.
 */

import { Hono } from "hono";
import { TokenStore } from "../store/token-store.js";
import { requireAdminAuth } from "../auth/middleware.js";
import { generateToken } from "../auth/crypto.js";
import type { PluginToken } from "../types.js";

export function createAdminRoutes(
	adminSecret: string,
	store: TokenStore
): Hono {
	const app = new Hono();

	// All admin routes require admin authentication
	app.use("/*", requireAdminAuth(adminSecret));

	// =========================================================================
	// Plugin Tokens CRUD
	// =========================================================================

	/**
	 * List all plugin tokens (without revealing the actual token values)
	 */
	app.get("/admin/plugin-tokens", (c) => {
		const tokens = store.listPluginTokens().map(sanitizeToken);
		return c.json({ tokens });
	});

	/**
	 * Register a new plugin token.
	 * Body: { name: string, token: string, pluginHost?: string, pluginPort?: number }
	 *
	 * The token value is typically generated by the Obsidian plugin and
	 * provided here during registration.
	 */
	app.post("/admin/plugin-tokens", async (c) => {
		let body: Record<string, unknown>;
		try {
			body = await c.req.json();
		} catch {
			return c.json({ error: "invalid_request" }, 400);
		}

		const name = body.name;
		const token = body.token;

		if (typeof name !== "string" || !name.trim()) {
			return c.json(
				{ error: "name is required and must be a non-empty string" },
				400
			);
		}

		if (typeof token !== "string" || !token.trim()) {
			return c.json(
				{ error: "token is required and must be a non-empty string" },
				400
			);
		}

		const pluginToken: PluginToken = {
			id: generateToken(8),
			name: name.trim(),
			token: token.trim(),
			pluginHost:
				typeof body.pluginHost === "string"
					? body.pluginHost
					: "127.0.0.1",
			pluginPort:
				typeof body.pluginPort === "number"
					? body.pluginPort
					: 3000,
			createdAt: Date.now(),
		};

		store.savePluginToken(pluginToken);

		console.error(`[Admin] Plugin token registered: ${pluginToken.name}`);

		return c.json({ token: sanitizeToken(pluginToken) }, 201);
	});

	/**
	 * Get a specific plugin token
	 */
	app.get("/admin/plugin-tokens/:id", (c) => {
		const id = c.req.param("id");
		const token = store.getPluginToken(id);

		if (!token) {
			return c.json({ error: "not_found" }, 404);
		}

		return c.json({ token: sanitizeToken(token) });
	});

	/**
	 * Delete a plugin token
	 */
	app.delete("/admin/plugin-tokens/:id", (c) => {
		const id = c.req.param("id");
		const deleted = store.deletePluginToken(id);

		if (!deleted) {
			return c.json({ error: "not_found" }, 404);
		}

		console.error(`[Admin] Plugin token deleted: ${id}`);
		return c.json({ deleted: true });
	});

	// =========================================================================
	// Server Status
	// =========================================================================

	app.get("/admin/status", (c) => {
		const pluginTokens = store.listPluginTokens();
		return c.json({
			status: "ok",
			pluginConnections: pluginTokens.length,
		});
	});

	return app;
}

/**
 * Remove sensitive token value, show only masked version
 */
function sanitizeToken(token: PluginToken): Omit<PluginToken, "token"> & {
	tokenMasked: string;
} {
	const { token: tokenValue, ...rest } = token;
	return {
		...rest,
		tokenMasked:
			tokenValue.length > 8
				? `${tokenValue.slice(0, 4)}...${tokenValue.slice(-4)}`
				: "****",
	};
}
