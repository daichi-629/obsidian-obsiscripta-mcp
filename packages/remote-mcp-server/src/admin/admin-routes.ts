/**
 * Admin API routes for managing plugin tokens.
 * Protected by admin secret (Bearer token).
 *
 * Plugin tokens are used for MCP server â†’ Obsidian plugin communication.
 * The Obsidian plugin generates a token, which is then registered here
 * via the admin API.
 */

import { Hono } from "hono";
import { TokenStore } from "../store/token-store.js";
import { requireAdminAuth } from "../auth/middleware.js";
import { generateToken } from "../auth/crypto.js";
import type { PluginToken } from "../types.js";

export function createAdminRoutes(
	adminSecret: string,
	store: TokenStore
): Hono {
	const app = new Hono();

	// All admin routes require admin authentication
	app.use("/*", requireAdminAuth(adminSecret));

	// =========================================================================
	// Plugin Tokens CRUD
	// =========================================================================

	/**
	 * List all plugin tokens (without revealing the actual token values)
	 * Query params:
	 *  - githubUserId: Filter by GitHub user ID
	 */
	app.get("/admin/plugin-tokens", (c) => {
		const githubUserIdParam = c.req.query("githubUserId");

		let tokens = store.listPluginTokens();

		// Filter by GitHub user ID if provided
		if (githubUserIdParam) {
			const githubUserId = parseInt(githubUserIdParam, 10);
			if (!isNaN(githubUserId)) {
				tokens = store.listPluginTokensByUserId(githubUserId);
			}
		}

		return c.json({ tokens: tokens.map(sanitizeToken) });
	});

	/**
	 * Register a new plugin token.
	 * Body: {
	 *   name: string,
	 *   token: string,
	 *   githubUserId: number,
	 *   pluginHost?: string,
	 *   pluginPort?: number,
	 *   requireAuth?: boolean
	 * }
	 *
	 * The token value is typically generated by the Obsidian plugin and
	 * provided here during registration.
	 */
	app.post("/admin/plugin-tokens", async (c) => {
		let body: Record<string, unknown>;
		try {
			body = await c.req.json();
		} catch {
			return c.json({ error: "invalid_request" }, 400);
		}

		const name = body.name;
		const token = body.token;
		const githubUserId = body.githubUserId;

		if (typeof name !== "string" || !name.trim()) {
			return c.json(
				{ error: "name is required and must be a non-empty string" },
				400
			);
		}

		if (typeof token !== "string" || !token.trim()) {
			return c.json(
				{ error: "token is required and must be a non-empty string" },
				400
			);
		}

		if (typeof githubUserId !== "number") {
			return c.json(
				{ error: "githubUserId is required and must be a number" },
				400
			);
		}

		const pluginToken: PluginToken = {
			id: generateToken(8),
			name: name.trim(),
			token: token.trim(),
			pluginHost:
				typeof body.pluginHost === "string"
					? body.pluginHost
					: "127.0.0.1",
			pluginPort:
				typeof body.pluginPort === "number"
					? body.pluginPort
					: 3000,
			githubUserId: githubUserId,
			requireAuth:
				typeof body.requireAuth === "boolean"
					? body.requireAuth
					: true,
			createdAt: Date.now(),
		};

		store.savePluginToken(pluginToken);

		console.error(`[Admin] Plugin token registered: ${pluginToken.name} for user ${pluginToken.githubUserId}`);

		return c.json({ token: sanitizeToken(pluginToken) }, 201);
	});

	/**
	 * Get a specific plugin token
	 */
	app.get("/admin/plugin-tokens/:id", (c) => {
		const id = c.req.param("id");
		const token = store.getPluginToken(id);

		if (!token) {
			return c.json({ error: "not_found" }, 404);
		}

		return c.json({ token: sanitizeToken(token) });
	});

	/**
	 * Update a plugin token
	 * Body: {
	 *   name?: string,
	 *   pluginHost?: string,
	 *   pluginPort?: number,
	 *   requireAuth?: boolean
	 * }
	 */
	app.put("/admin/plugin-tokens/:id", async (c) => {
		const id = c.req.param("id");
		const existingToken = store.getPluginToken(id);

		if (!existingToken) {
			return c.json({ error: "not_found" }, 404);
		}

		let body: Record<string, unknown>;
		try {
			body = await c.req.json();
		} catch {
			return c.json({ error: "invalid_request" }, 400);
		}

		const updatedToken: PluginToken = {
			...existingToken,
			name:
				typeof body.name === "string" && body.name.trim()
					? body.name.trim()
					: existingToken.name,
			pluginHost:
				typeof body.pluginHost === "string"
					? body.pluginHost
					: existingToken.pluginHost,
			pluginPort:
				typeof body.pluginPort === "number"
					? body.pluginPort
					: existingToken.pluginPort,
			requireAuth:
				typeof body.requireAuth === "boolean"
					? body.requireAuth
					: existingToken.requireAuth,
		};

		store.savePluginToken(updatedToken);

		console.error(`[Admin] Plugin token updated: ${id}`);

		return c.json({ token: sanitizeToken(updatedToken) });
	});

	/**
	 * Delete a plugin token
	 */
	app.delete("/admin/plugin-tokens/:id", (c) => {
		const id = c.req.param("id");
		const deleted = store.deletePluginToken(id);

		if (!deleted) {
			return c.json({ error: "not_found" }, 404);
		}

		console.error(`[Admin] Plugin token deleted: ${id}`);
		return c.json({ deleted: true });
	});

	// =========================================================================
	// Server Status
	// =========================================================================

	app.get("/admin/status", (c) => {
		const pluginTokens = store.listPluginTokens();
		return c.json({
			status: "ok",
			pluginConnections: pluginTokens.length,
		});
	});

	return app;
}

/**
 * Remove sensitive token value, show only masked version
 */
function sanitizeToken(token: PluginToken): Omit<PluginToken, "token"> & {
	tokenMasked: string;
} {
	const { token: tokenValue, ...rest } = token;
	return {
		...rest,
		tokenMasked:
			tokenValue.length > 8
				? `${tokenValue.slice(0, 4)}...${tokenValue.slice(-4)}`
				: "****",
	};
}
