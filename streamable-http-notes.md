**Streamable HTTP server memo**
- Transport model: Streamable HTTP uses regular HTTP endpoints with a long-lived GET for streaming events; the transport object owns request parsing, response formatting, and SSE details.
- Session lifecycle: first request is POST `/mcp` with an initialize payload and no `mcp-session-id`; server creates a `StreamableHTTPServerTransport`, stores it by sessionId, connects MCP server, then calls `handleRequest`.
- Session ID source: the transport generates the session ID (via `sessionIdGenerator`), then calls `onsessioninitialized` so the server can safely store it before any follow-up requests arrive.
- Session routing: subsequent POST/GET/DELETE requests include `mcp-session-id` header and must reuse the existing transport; do not call `server.connect` again for that session.
- GET stream: GET `/mcp` establishes the SSE stream for the session; the transport’s `handleRequest` wires the response into the stream. It is separate from the POST request that carries JSON-RPC payloads.
- Resumability: use an `eventStore` (e.g., `InMemoryEventStore`) so SSE can replay missed events on reconnect; client can send `Last-Event-ID` and transport will replay as needed.
- Cleanup: set `transport.onclose` to remove the transport from the session map; also close transports on shutdown to prevent leaks.
- Error handling: if sessionId is missing/invalid for non-initialize requests, return a JSON-RPC error; guard with `if (!res.headersSent)` before sending 500s.
- Concurrency: a map of sessionId → transport is required to support multiple concurrent sessions; avoid shared global transport state.
- Server creation: the sample creates a new `McpServer` per session in `getServer()` and connects it to that session’s transport; this ensures isolation between sessions.
- Routes: POST `/mcp` handles initialize and JSON-RPC messages; GET `/mcp` handles SSE stream; DELETE `/mcp` handles termination per MCP spec.
- Auth (optional): OAuth metadata routes can be added; bearer auth middleware can protect `/mcp` routes; for local-only usage this can be omitted.
- Logging: `server.sendLoggingMessage` can emit MCP log events tied to a session via `extra.sessionId`.
- Elicitation: tools can use `extra.sendRequest` with `elicitation/create` and a schema to request user input; useful for interactive flows.
- Resource patterns: tools can return `ResourceLink` entries for lazy content access; `registerResource` provides read handlers for actual content.
- Task support: experimental tasks API uses a shared `taskStore` and `taskMessageQueue`; not required for basic tool calls but impacts server capabilities.
